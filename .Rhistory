geom_sf(data=cours_deau,size=0.5,col="#9ED6E3") +
geom_sf(data=rcs,aes(fill=TYPE_DE_ST),size=3,shape=21)+
scale_fill_manual("Station RCS :",
values= c("Référence"= "#9DC544" ,
"Surveillance"="#275662"))+
coord_sf(xlim = c(-54.631432, -51.620220), ylim = c(2.089382, 5.762563 ), expand = TRUE)+
geom_sf_label(data=france_bonus %>%
filter(admin != "France"),
aes(label = stringr::str_to_upper(admin)),
size=3,
col="#275662")+
# geom_sf_text(data=rcs,
#              aes(label=NOM_DE_LA),
#              nudge_x = -5, nudge_y = -5,
#              # seed = 10,
#              size=3)+
ggrepel::geom_text_repel(
data =rcs,
aes(label = NOM_DE_LA, geometry = geometry),
stat = "sf_coordinates",
min.segment.length = 0,
col="#275662"
)+
labs(title = "Réseau de contrôle de surveillance des cours d'eau de Guyane",
caption="Réalisation : Sébastien, Boutry (Inrae)")+
InraeThemes::theme_inrae() +
theme(axis.text = element_blank(),
legend.position = "right",
axis.title = element_blank(),
plot.title = element_text(size=20,
face="bold"),
plot.caption=element_text(size=10),
panel.background = element_rect(fill ="#9ED6E3")
)
carte
plan_deau <- sf::st_read("doc_guide_idgf/MasseDEauPlanDEau_GUF.shp") #%>%
library(lakemetrics)
build_site()
pkgdown::build_site()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
data(lac)
data(bv)
graph <- ggplot()+
geom_sf(data=bv)+
geom_sf(data=lac,fill="lightblue")+
theme_minimal()
print(graph)
shoreline<- shoreline_lake(lac)
print(shoreline)
area <- area_lake(lac)
print(area)
sdi <- sdi_lake(lac)
print(sdi)
data(nbr_transect_base)
kable(nbr_transect_base)
library(kableExtra)
data(nbr_transect_base)
kable(nbr_transect_base)
data(nbr_transect_base)
kable(nbr_transect_base)
kable(nbr_transect_base)
data(nbr_transect_base)
kable(nbr_transect_base)
nbr_transect_base
gt(nbr_transect_base)
data(nbr_transect_base)
gt(nbr_transect_base)
gt::gt(nbr_transect_base)
kableExtra::kable(nbr_transect_base)
gt::gt(nbr_transect_base)
data(nbr_transect_base)
gt::gt(nbr_transect_base)
data(lac)
baseline <- linemax_lake(lac)
transects <- transects_ibml(lac,baseline)
sppolygon<-lac
linemax<-baseline
if (! class(sppolygon)[1] %in% c("sfc_POLYGON","sf") ) {
stop("la masse eau n'est pas un objet sf")
}
if (!sf::st_geometry_type(sppolygon, by_geometry = TRUE) %>%
as.character() %in% c("MULTIPOLYGON", "POLYGON")) {
stop("la masse eau n'est pas de la classe MULTIPOLYGON ou POLYGON")
}
if(is.na(ntb_ibml(sppolygon))){
distance <-150
}else{
distance <- (linemax %>% sf::st_length()/(ntb_ibml(sppolygon))) %>% as.numeric()
}
grid_output <- allwidths_lake(sppolygon,linemax,distance) %>%
dplyr::mutate(classe="transects") %>%
rbind(linemax %>%
dplyr::select(-longueur) %>%
dplyr::rename("geometry"="geom_point") %>%
dplyr::mutate(classe="ligne de base")) %>%
dplyr::mutate(longueur=sf::st_length(geometry) %>% as.numeric()) %>%
dplyr::filter(longueur>0) %>%
dplyr::select(-longueur)
allwidths_lake(sppolygon,linemax,distance)
allwidths_lake(sppolygon,linemax,distance) %>%
dplyr::mutate(classe="transects") %>%
rbind(linemax %>%
dplyr::select(-longueur) %>%
dplyr::rename("geometry"="geom_point") %>%
dplyr::mutate(classe="ligne de base"))
grid_output <- allwidths_lake(sppolygon,linemax,distance) %>%
dplyr::mutate(classe="transects") %>%
rbind(linemax %>%
sf::st_transform(2154) |>
dplyr::select(-longueur) %>%
dplyr::rename("geometry"="geom_point") %>%
dplyr::mutate(classe="ligne de base")) %>%
dplyr::mutate(longueur=sf::st_length(geometry) %>% as.numeric()) %>%
dplyr::filter(longueur>0) %>%
dplyr::select(-longueur)
grid_output
data(lac)
baseline <- linemax_lake(lac)
transects <- transects_ibml(lac,baseline)
library(lakemetrics)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
transects <- transects_ibml(lac,baseline)
graph <- ggplot(data=lac)+
geom_sf(fill="lightblue")+
geom_sf(data=transects,aes(col=classe))+
#ggsn::north(data=lac, location = "bottomright", symbol = 15)
theme(legend.position = "bottom")
print(graph)
pkgdown::build_site()
bathymetry_lake(lac,bathy)
sppolygon<-lac
pts_bathy<-bathy
bathy
if (! class(sppolygon)[1] %in% c("sfc_POLYGON","sf","sfc_MULTIPOLYGON") ) {
stop("la masse eau n'est pas un objet sf")
}
if (!sf::st_geometry_type(sppolygon, by_geometry = TRUE) %>%
as.character() %in% c("MULTIPOLYGON", "POLYGON")) {
stop("la masse eau n'a pas d du type geom MULTIPOLYGON ou POLYGON")
}
if (! class(pts_bathy)[1] %in% c("sf") ) {
stop("l'objet pts_bathy n'est pas un objet sf")
}
if (sf::st_coordinates(pts_bathy) %>% ncol()!=3) {
stop("l'objet pts_bathy n'est pas un objet à trois dimensions XYZ")
}
##
##
pts_bathy_modify <- pts_bathy %>%
cbind(.,sf::st_coordinates(.)) %>%
dplyr::select(-X,-Y) %>%
dplyr::rename("depth"="Z") %>%
dplyr::mutate(source="measured") %>%
sf::st_zm()
##
##
boundary_points <- sf::st_cast(sppolygon, "POINT") %>%
sf::st_as_sf() %>%
dplyr::rename("geometry"="x") %>%
dplyr::mutate(source= "boundary",depth = 0) %>%
dplyr::select(source,depth,geometry)
##
depths <- dplyr::bind_rows(boundary_points,  pts_bathy_modify) %>%
dplyr::select(source,depth,geometry) %>%
cbind(., sf::st_coordinates(.)) %>%
dplyr::distinct_all()
##
grid <- sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf() %>%
dplyr::filter(sf::st_contains(sppolygon, ., sparse = FALSE)) %>%
cbind(., sf::st_coordinates(.)) %>%
dplyr::rename("geometry"="x")
cellsize
cellsize=10
##
grid <- sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf() %>%
dplyr::filter(sf::st_contains(sppolygon, ., sparse = FALSE)) %>%
cbind(., sf::st_coordinates(.)) %>%
dplyr::rename("geometry"="x")
sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers")
sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf()
sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf() %>%
dplyr::filter(sf::st_contains(sppolygon, ., sparse = FALSE))
grid <- sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf()
sf::st_contains(sppolygon,
grid,
sparse = FALSE)
sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf() %>%
dplyr::filter(sf::st_contains(sppolygon,
.,
sparse = FALSE))
sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf()
##
grid <- sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf() %>%
mutate(sf::st_contains(sppolygon,
.,
sparse = FALSE))
grid
grid <-   dplyr::filter(sf::st_contains(sppolygon,
grid,
sparse = FALSE)) %>%
cbind(., sf::st_coordinates(.)) %>%
dplyr::rename("geometry"="x")
##
grid <- sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf()
grid <-   dplyr::filter(sf::st_contains(sppolygon,
grid,
sparse = FALSE)) %>%
cbind(., sf::st_coordinates(.)) %>%
dplyr::rename("geometry"="x")
sf::st_contains(sppolygon,
grid,
sparse = FALSE)
grid <-  grid |>  dplyr::filter(sf::st_contains(sppolygon,
grid,
sparse = FALSE)) %>%
cbind(., sf::st_coordinates(.)) %>%
dplyr::rename("geometry"="x")
grid <- sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf()
grid
sppolygon
st_intersects(grid,sppolygon
)
st_intersection(grid,sppolygon)
##
grid <- sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf() %>%
st_intersection(sppolygon) |>
# dplyr::filter(sf::st_contains(sppolygon,
#                               .,
#                               sparse = FALSE)) %>%
cbind(., sf::st_coordinates(.)) %>%
dplyr::rename("geometry"="x")
##
grid <- sf::st_make_grid(sppolygon,
cellsize = c(cellsize, cellsize),
what = "centers") %>%
sf::st_as_sf() %>%
st_intersection(sppolygon) %>%
# dplyr::filter(sf::st_contains(sppolygon,
#                               .,
#                               sparse = FALSE)) %>%
cbind(., sf::st_coordinates(.)) %>%
dplyr::rename("geometry"="x")
grid
# Inverse Distance Weighting (IDW)
fit_gstat <- gstat::gstat(
formula = depth ~ 1,
data = as(depths, "Spatial"),
nmax = 10, nmin = 3,
set = list(idp = 0.5)
)
grid$IDW <- stats::predict(fit_gstat, newdata = as(grid, "Spatial")) %>%
sf::st_as_sf() %>%
dplyr::pull(1)
# Thin Plate Regression Spline (TPRS)
fit_gam_reml <- mgcv::gam(depth ~ s(X, Y, k = 60), data = depths, method = "REML")
grid$TPRS <- stats::predict(fit_gam_reml, newdata = grid, type = "response")
## Soap Film Smooth
boundary_coords <- sf::st_coordinates(sppolygon)
gam_bound  <- list(
list(
X = boundary_coords[-1, "X"],
Y = boundary_coords[-1, "Y"],
f = rep(0, nrow(boundary_coords))
)
)
knot_points <- sf::st_make_grid(
sppolygon,
n = c(10, 10),
what = "centers"
) %>%
sf::st_as_sf() %>%
dplyr::filter(sf::st_contains(sppolygon, x, sparse = FALSE)) %>%
dplyr::filter(
!sf::st_intersects(
sppolygon %>% sf::st_cast("LINESTRING") %>% sf::st_buffer(10),
x,
sparse = FALSE
)
) %>%
cbind(., sf::st_coordinates(.))
fit_gam_soap <- mgcv::gam(
depth ~ s(X, Y, bs = "so", xt = list(bnd = gam_bound)),
data = depths %>%
dplyr::filter(source == "measured") %>%
dplyr::filter(sf::st_contains(sppolygon, geometry, sparse = FALSE)),
method = "REML",
knots = knot_points
)
grid$GAM_Soap <- stats::predict(fit_gam_soap, newdata = grid, type = "response")
grid
# Inverse Distance Weighting (IDW)
fit_gstat <- gstat::gstat(
formula = depth ~ 1,
data = as(depths, "Spatial"),
nmax = 10, nmin = 3,
set = list(idp = 0.5)
)
grid$IDW <- stats::predict(fit_gstat, newdata = as(grid, "Spatial")) %>%
sf::st_as_sf() %>%
dplyr::pull(1)
# Thin Plate Regression Spline (TPRS)
fit_gam_reml <- mgcv::gam(depth ~ s(X, Y, k = 60), data = depths, method = "REML")
grid$TPRS <- stats::predict(fit_gam_reml, newdata = grid, type = "response")
## Soap Film Smooth
boundary_coords <- sf::st_coordinates(sppolygon)
gam_bound  <- list(
list(
X = boundary_coords[-1, "X"],
Y = boundary_coords[-1, "Y"],
f = rep(0, nrow(boundary_coords))
)
)
knot_points <- sf::st_make_grid(
sppolygon,
n = c(10, 10),
what = "centers"
) %>%
sf::st_as_sf() %>%
dplyr::filter(sf::st_contains(sppolygon, x, sparse = FALSE)) %>%
dplyr::filter(
!sf::st_intersects(
sppolygon %>% sf::st_cast("LINESTRING") %>% sf::st_buffer(10),
x,
sparse = FALSE
)
) %>%
cbind(., sf::st_coordinates(.))
knot_points <- sf::st_make_grid(
sppolygon,
n = c(10, 10),
what = "centers"
) %>%
sf::st_as_sf() %>%
st_intersection(sppolygon) %>%
# dplyr::filter(sf::st_contains(sppolygon, x, sparse = FALSE)) %>%
dplyr::filter(
!sf::st_intersects(
sppolygon %>% sf::st_cast("LINESTRING") %>% sf::st_buffer(10),
x,
sparse = FALSE
)
) %>%
cbind(., sf::st_coordinates(.))
sf::st_make_grid(
sppolygon,
n = c(10, 10),
what = "centers"
) %>%
sf::st_as_sf()
sf::st_make_grid(
sppolygon,
n = c(10, 10),
what = "centers"
) %>%
sf::st_as_sf() %>%
st_intersection(sppolygon)
sf::st_make_grid(
sppolygon,
n = c(10, 10),
what = "centers"
) %>%
sf::st_as_sf() %>%
st_intersection(sppolygon) %>%
# dplyr::filter(sf::st_contains(sppolygon, x, sparse = FALSE)) %>%
dplyr::filter(
!sf::st_intersects(
sppolygon %>% sf::st_cast("LINESTRING") %>% sf::st_buffer(10),
x,
sparse = FALSE
)
)
sppolygon %>% sf::st_cast("LINESTRING") %>% sf::st_buffer(10)
?st_intersection
knot_points <- sf::st_make_grid(
sppolygon,
n = c(10, 10),
what = "centers"
) %>%
sf::st_as_sf() %>%
st_intersection(sppolygon) %>%
# dplyr::filter(sf::st_contains(sppolygon, x, sparse = FALSE)) %>%
st_difference(sppolygon %>% sf::st_cast("LINESTRING") %>% sf::st_buffer(10))
knot_points
knot_points <- sf::st_make_grid(
sppolygon,
n = c(10, 10),
what = "centers"
) %>%
sf::st_as_sf() %>%
st_intersection(sppolygon)
knot_points
knot_points <- sf::st_make_grid(
sppolygon,
n = c(10, 10),
what = "centers"
) %>%
sf::st_as_sf() %>%
st_intersection(sppolygon) %>%
# dplyr::filter(sf::st_contains(sppolygon, x, sparse = FALSE)) %>%
st_difference(sppolygon %>% sf::st_cast("LINESTRING") %>% sf::st_buffer(10)) %>%
# dplyr::filter(
#   !sf::st_intersects(
#     sppolygon %>% sf::st_cast("LINESTRING") %>% sf::st_buffer(10),
#     x,
#     sparse = FALSE
#   )
# ) %>%
cbind(., sf::st_coordinates(.))
fit_gam_soap <- mgcv::gam(
depth ~ s(X, Y, bs = "so", xt = list(bnd = gam_bound)),
data = depths %>%
dplyr::filter(source == "measured") %>%
st_intersection(sppolygon),
# dplyr::filter(sf::st_contains(sppolygon, geometry, sparse = FALSE)),
method = "REML",
knots = knot_points
)
grid$GAM_Soap <- stats::predict(fit_gam_soap, newdata = grid, type = "response")
##
##
grid_nested <- grid %>%
sf::st_drop_geometry() %>%
tidyr::pivot_longer(c("IDW","TPRS","GAM_Soap")) %>%
dplyr::group_by(name) %>%
tidyr::nest() %>%
dplyr::mutate(depth_raster_output=purrr::map(data,rasterizeptsbathy))
diff <- NULL
for(i in grid_nested$name){
depth_raster <- grid_nested %>% dplyr::filter(name==i) %>% dplyr::pull(depth_raster_output)
diff <- c(diff,diffrasterpts(depth_raster[[1]] , pts_bathy))
}
names(diff) <- grid_nested$name
best_select <- which.min(diff)
best_select
##
best_grid <- grid_nested$data[[3]] %>%
sf::st_as_sf(coords=c("X","Y"),crs=2154) %>%
cbind(., sf::st_coordinates(.))
best_grid
library(lakemetrics)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
data(lac)
baseline <- linemax_lake(lac)
transects <- transects_ibml(lac,baseline)
graph <- ggplot(data=lac)+
geom_sf(fill="lightblue")+
geom_sf(data=transects,aes(col=classe))+
#ggsn::north(data=lac, location = "bottomright", symbol = 15)
theme(legend.position = "bottom")
print(graph)
bathymetry_lake(lac,bathy)
grid_nested
bathymetry_lake(lac,bathy)->A
A
A |> ggplot()+geom_sf(aes(value))
A |> ggplot()+geom_sf(aes(col=value))
library(lakemetrics)
data(lac)
baseline <- linemax_lake(lac)
transects <- transects_ibml(lac,baseline)
transects
library(ggplot2)
import(ggplot2)
use_package('ggplot2')
devtools::use_package('ggplot2')
??use_package
usethis::use_package("ggplot2")
usethis::use_package("gt")
